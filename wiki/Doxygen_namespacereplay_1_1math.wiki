
==replay::math Reference==
Math related functions. 
====default_epsilon====
{{{
  const float replay::math::default_epsilon
}}}
  default numerical error tolerance. 
====m_pi====
{{{
  const float replay::math::m_pi
}}}
  the ratio of a circle's circumference to its diameter. 
====abs====
{{{
  type replay::math::abs(type value)
}}}
  get the absolute of a value. 
====angle_vector====
{{{
  replay::vector2f replay::math::angle_vector(const float radians)
}}}
  Computes a 2d vector pointing at the given angle relative to x+. radiansAngle in radians. 
====clamp====
{{{
  T replay::math::clamp(const T value, const couple< T > &range)
}}}
  Clamp a value into a range. 
====clamp====
{{{
  T replay::math::clamp(const T value, const T a, const T b)
}}}
  Clamp a value into a range. 
====clampabs====
{{{
  T replay::math::clampabs(const T value, const T abs)
}}}
  clamp a value into the range [-abs,abs] 
====compute_frustum_corners====
{{{
  void replay::math::compute_frustum_corners(const plane3 *frustum, vector3f *points)
}}}
  Find the frustum corners from the 6 given frustum points. 
====construct_circle====
{{{
  void replay::math::construct_circle(const vector2f &a, const vector2f &b, const vector2f &c, vector2f &m, float &radius)
}}}
  Construct a circle from three points. If the points are colinear, a negative radius is returned. 
====construct_circumcircle====
{{{
  bool replay::math::construct_circumcircle(const vector3f &a, const vector3f &b, const vector3f &c, vector3f &m, float &square_radius)
}}}
  Construct the circumcircle of a triangle. 
====construct_perpendicular====
{{{
  replay::vector3f replay::math::construct_perpendicular(const vector3f &x)
}}}
  construct a vector that is perpendicular to the given one. 
====construct_sphere====
{{{
  boost::tuple< replay::vector3f, float > replay::math::construct_sphere(boost::array< replay::vector3f, 4 > P)
}}}
  Compute a sphere from 4 non-coplanar points. The square of the radius and center if the points are not coplanar, otherwise the center is undefined and the radius is negative. 
====convert_to_degrees====
{{{
  float replay::math::convert_to_degrees(const float radians)
}}}
  convert radians to degrees. 
====convert_to_radians====
{{{
  float replay::math::convert_to_radians(const float degrees)
}}}
  convert degrees to radians. 
====convex_hull_contains====
{{{
  unsigned int replay::math::convex_hull_contains(vector2f *hull, unsigned int hullsize, const vector2f &point, const float threshold)
}}}
  Checks whether the given point is inside the given convex hull. 
====copy_sign====
{{{
  float replay::math::copy_sign(float value, const float sign)
}}}
  get the sign of an integer. 1 for negative numbers and 0 for others. copies the sign. 
====decompose_rotational_matrix====
{{{
  void replay::math::decompose_rotational_matrix(const matrix3 &m, quaternion &result)
}}}
  Decompose a rotational matrix into a quaternion. Effectively a conversion between the two. mMatrix to decompose. resultQuaternion to store the resulting rotation. 
====decompose_rotational_matrix====
{{{
  void replay::math::decompose_rotational_matrix(const matrix4 &m, quaternion &result)
}}}
  Decompose the rotational part of a 4x4 matrix into a quaternion. The top left 3x3 part of the matrix is converted to a quaternion. mMatrix to decompose. resultQuaternion to store the resulting rotation. 
====det====
{{{
  float replay::math::det(const vector2f &a, const vector2f &b)
}}}
  compute the determinante of a 2x2 matrix given as two vectors. 
====det====
{{{
  float replay::math::det(const float a, const float b, const float c, const float d)
}}}
  compute the determinante of a 2x2 matrix given as 4 values. 
====extract_frustum====
{{{
  void replay::math::extract_frustum(const matrix4 &scene, plane3 *frustum)
}}}
  Extract the view frustum planes from a given scene matrix. The normals of the resulting planes are pointing inwards, i.e. the intersection of all positive sides is 'in'. sceneThe scene matrix is Projection * Modelview frustumArray of the 6 frustum planes, left, right, bottom, top, near, far in that order. 
====extract_frustum_sides====
{{{
  void replay::math::extract_frustum_sides(const matrix4 &scene, plane3 *frustum)
}}}
  Extract the view frustum side planes from a given scene matrix. sceneThe scene matrix is Projection * Modelview frustumArray of the 4 frustum planes, left, right, bottom, top in that order. 
====gift_wrap====
{{{
  unsigned int replay::math::gift_wrap(vector2f *points, unsigned int count)
}}}
  Find a 2D convex hull of a set of 2d vectors using the gift wrap algorithm. The points are reordered so that the first points make up a convex hull of the set. pointsThe points to find the convex hull of. countThe number of points in the set. The number of points that make up the convex hull. 
====gift_wrap2====
{{{
  unsigned int replay::math::gift_wrap2(vector3f *points, unsigned int count)
}}}
  Find a 2D convex hull of a set of 2d vectors using the gift wrap algorithm. The points are reordered so that the first points make up a convex hull of the set. pointsThe points to find the convex hull of. countThe number of points in the set. The number of points that make up the convex hull. 
====in_range====
{{{
  bool replay::math::in_range(const T value, const T left, const T right)
}}}
  check if the value is in the range. borders count as in. 
====in_range====
{{{
  bool replay::math::in_range(const T value, const couple< T > &range)
}}}
  check if the value is in the range. borders count as in. 
====intersect_3planes====
{{{
  replay::vector3f replay::math::intersect_3planes(const plane3 &a, const plane3 &b, const plane3 &c)
}}}
  Find the intersection point of the 3 given planes, if such a point exists. 
====intersect_line2====
{{{
  bool replay::math::intersect_line2(const line2 &a, const line2 &b, vector2f &result)
}}}
  Compute the intersection of two 2d lines. 
====intervals_intersect====
{{{
  bool replay::math::intervals_intersect(const couple< T > &a, const couple< T > &b)
}}}
  check whether two intervals intersect. 
====is_pow2====
{{{
  bool replay::math::is_pow2(int Number)
}}}
  returns true if the given integer is a power of two. 
====is_pow2====
{{{
  bool replay::math::is_pow2(unsigned int Number)
}}}
  returns true if the given integer is a power of two. 
====lerp====
{{{
  type replay::math::lerp(const type a, const type b, const delta_type x)
}}}
  linear interpolation. 
====make_orthographic_matrix====
{{{
  matrix4 replay::math::make_orthographic_matrix(const fcouple &width, const fcouple &height, const fcouple &depth)
}}}
  setup an orthographic matrix for homogenous coordinates. 
====make_perspective_matrix====
{{{
  matrix4 replay::math::make_perspective_matrix(float fovy, float aspect, float near, float far)
}}}
  setup a perspective matrix for homogenous coordinates. 
====max_norm====
{{{
  float replay::math::max_norm(const vector2f &vector)
}}}
  compute the length of a vector in manhattan norm. (max-norm) 
====max_norm====
{{{
  float replay::math::max_norm(const vector3f &vector)
}}}
  compute the length of a vector in manhatten norm. (max-norm) 
====minimal_sphere====
{{{
  void replay::math::minimal_sphere(vector3f *p, std::size_t n, vector3f &m, float &r)
}}}
  Construct the minimal sphere containing a set of points using Welzl's algorithm. Expected linear runtime. This will permute the points in the given array. pArray of points. nNumber of points in the array. mCenter of the computed sphere. rSquared radius of the computed sphere. 
====mult_by_sign====
{{{
  vector3f replay::math::mult_by_sign(const vector3f &x, float sign)
}}}
  vector component wise mult by sign. 
====mult_by_sign====
{{{
  void replay::math::mult_by_sign(float a, float b, float &result)
}}}
  multiply a only by the sign of b. 
====mult_ref_by_sign====
{{{
  void replay::math::mult_ref_by_sign(float &a, float b)
}}}
  get the absolute of a value. multiply a only by the sign of b. 
====near====
{{{
  bool replay::math::near(const float a, const float b)
}}}
  return true if a is within a treshold of b. 
====near_zero====
{{{
  bool replay::math::near_zero(const float value, const float epsilon)
}}}
  return true if the value is within a treshold of zero. 
====near_zero====
{{{
  bool replay::math::near_zero(const float value)
}}}
  return true if the value is within a treshold of zero. 
====same_sign====
{{{
  unsigned int replay::math::same_sign(float a, float b)
}}}
  compare signs. 
====saturate====
{{{
  float replay::math::saturate(float x)
}}}
  Saturate the value, i.e., clamp it into the [0..1] range. xValue to be saturated. 
====set_orthographic_matrix====
{{{
  void replay::math::set_orthographic_matrix(matrix4 &matrix, const fcouple &width, const fcouple &height, const fcouple &depth)
}}}
  setup an orthographic matrix for homogenous coordinates. 
====set_perspective_matrix====
{{{
  void replay::math::set_perspective_matrix(matrix4 &matrix, float fovy, float aspect, float near, float far)
}}}
  setup a perspective matrix for homogenous coordinates. 
====sign====
{{{
  unsigned int replay::math::sign(float value)
}}}
  find the sign. 
====smoothstep====
{{{
  float replay::math::smoothstep(float edge0, float edge1, float x)
}}}
  Perform a smooth hermite blend between two edge values. Returns 0 for values smaller than edge0 and 1 for values greater than edge1. Values in between are interpolated by the polynomial x*x*(3-2*x). 
====solve_quadratic_eq====
{{{
  unsigned int replay::math::solve_quadratic_eq(float a, float b, float c, fcouple &result, float epsilon)
}}}
  Solve a quadratic equation of the form: a*x^2+b*x+c=0. 
====splice2====
{{{
  vector2< x > replay::math::splice2(const vector3< x > &v)
}}}
  splice off the first two elements. 
====square====
{{{
  T replay::math::square(T p)
}}}
  compute the square. 
====vector_max====
{{{
  vector2< x > replay::math::vector_max(const vector2< x > &a, const vector2< x > &b)
}}}
  vector component wise max. 
====vector_max====
{{{
  vector3< x > replay::math::vector_max(const vector3< x > &a, const vector3< x > &b)
}}}
  vector component wise max. 
====vector_min====
{{{
  vector2< x > replay::math::vector_min(const vector2< x > &a, const vector2< x > &b)
}}}
  vector component wise min. 
====vector_min====
{{{
  vector3< x > replay::math::vector_min(const vector3< x > &a, const vector3< x > &b)
}}}
  vector component wise min. 