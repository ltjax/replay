
==replay::equisphere Reference==

{{{
#include minimal_sphere.hpp
}}}
Incrementaly construct a d-dimensional point that is equidistant to all input points, i.e. all points are on the boundary of a d-dimensional sphere. This data structure is numerically robust and will reject point pushes that degenerate the numerical stability (i.e. that are very close to the existing ball). The code is based on the paper 'Fast and Robust Smallest Enclosing Balls' by Bernd Gaertner. 
====matrix_type====
{{{
  typedef upper_unitriangular_matrix<d+1> replay::equisphere< RealType, d >::matrix_type
}}}
  
====a====
{{{
  matrix_type replay::equisphere< RealType, d >::a
}}}
  
====center====
{{{
  RealType replay::equisphere< RealType, d >::center[d+1][d][d+1][d]
}}}
  
====epsilon====
{{{
  const RealType replay::equisphere< RealType, d >::epsilon
}}}
  
====f====
{{{
  RealType replay::equisphere< RealType, d >::f[d][d]
}}}
  
====initial_point====
{{{
  RealType replay::equisphere< RealType, d >::initial_point[d][d]
}}}
  
====m====
{{{
  std::size_t replay::equisphere< RealType, d >::m
}}}
  
====P====
{{{
  RealType replay::equisphere< RealType, d >::P[d][d][d][d]
}}}
  
====sqr_radius====
{{{
  RealType replay::equisphere< RealType, d >::sqr_radius[d+1][d+1]
}}}
  
====z====
{{{
  RealType replay::equisphere< RealType, d >::z[d][d]
}}}
  
====equisphere====
{{{
  replay::equisphere< RealType, d >::equisphere(RealType epsilon)
}}}
  
====get_center====
{{{
  const RealType* replay::equisphere< RealType, d >::get_center() const 
}}}
  
====get_squared_radius====
{{{
  RealType replay::equisphere< RealType, d >::get_squared_radius() const 
}}}
  
====get_support_count====
{{{
  std::size_t replay::equisphere< RealType, d >::get_support_count() const 
}}}
  
====pop====
{{{
  void replay::equisphere< RealType, d >::pop()
}}}
  
====push====
{{{
  bool replay::equisphere< RealType, d >::push(const VectorType &p)
}}}
  