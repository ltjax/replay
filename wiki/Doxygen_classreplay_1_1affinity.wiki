
==replay::affinity Reference==

{{{
#include affinity.hpp
}}}
Describe an orthogonal affine mapping, equivalent to a rotation and an offset. The mapping is of the form $x \longrightarrow Rx+p$, where $R$ is the member variable orientation, represented as a quaternion, and $p$ is position, represented as a vector3<float>. As such, it is probably the most common mapping used in 3d graphics.The following rules apply for 3 affinities $a,b,c$:
 Associativity, i.e. $(ab)c = a(bc)$.
 One, i.e. $a1 = 1a = a$.
 Inverse elements, i.e. $aa^{-1} = a^{-1}a = 1$.The one is generated by the default constructor, the inverse can be computed by inverse.Multiplicating two affinities is isomorphic to concaternating the functions they represent, but this is computationally cheaper than multiplying matrices representing the same functions. Likewise, finding the inverse is much cheaper than doing it on their matrix counterparts. 
====orientation====
{{{
  quaternion replay::affinity::orientation
}}}
  Rotational part of this transformation. 
====position====
{{{
  vector3f replay::affinity::position
}}}
  Offset part of this transformation. 
====affinity====
{{{
  replay::affinity::affinity()
}}}
  construct a default identity transformation. 
====affinity====
{{{
  replay::affinity::affinity(const vector3f &position)
}}}
  Construct a mapping based on an offset. 
====affinity====
{{{
  replay::affinity::affinity(const quaternion &orientation, const vector3f &position)
}}}
  Construct a mapping based on an orientation and an offset. 
====affinity====
{{{
  replay::affinity::affinity(const quaternion &orientation)
}}}
  Construct a mapping based on an orientation. 
====matrix====
{{{
  const matrix4 replay::affinity::matrix() const 
}}}
  Get this mapping as a homogenous 4x4 matrix. 
====operator*====
{{{
  const vector3f replay::affinity::operator*(const vector3f &rhs) const 
}}}
  Transform a position vector by this mapping. 
====operator*====
{{{
  affinity replay::affinity::operator*(const affinity &other) const 
}}}
  Concaternate two mappings a and b. the effect is as if b and a were executed in that order. 
====operator*=====
{{{
  affinity& replay::affinity::operator*=(const affinity &other)
}}}
  Inplace concaternate two mappings a and b. the effect is as if b and a were executed in that order. 
====blend====
{{{
  static const affinity replay::affinity::blend(const affinity &lhs, const affinity &rhs, float x)
}}}
  Blend smoothly between two affinities. lhsThe first affinity. rhsThe second affinity. xA value in $[0..1]$, selecting blend fraction between a and b. Result of the blending. Uses quaternion::nlerp internally. This is not a linear operator. 
====inverse====
{{{
  static const affinity replay::affinity::inverse(const affinity &rhs)
}}}
  Find the inverse of the given affinity. rhsThe original mapping of which to find the inverse. The inverse of the mapping. 