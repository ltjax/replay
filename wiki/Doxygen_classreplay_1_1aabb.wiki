
==replay::aabb Reference==

{{{
#include aabb.hpp
}}}
An iso-box in $R^3$. Represents the intersection of intervals on the 3 principal axes. 
====clsfctn====
  Classification relative to a plane. 
  =====negative=====
  all points have a negative distance. 
  =====positive=====
  all points have a positive distance. 
  =====spanning=====
  the points have mixed signs in their distances. 
====base_class====
{{{
  typedef couple<vector3f> replay::aabb::base_class
}}}
  
====aabb====
{{{
  replay::aabb::aabb()
}}}
  Create a new empty box that contains nothing. 
====aabb====
{{{
  replay::aabb::aabb(const float extends)
}}}
  Create a new box that extends in all directions from the origin. 
====aabb====
{{{
  replay::aabb::aabb(const vector3f &min, const vector3f &max)
}}}
  Create a new box from range. 
====classify====
{{{
  replay::aabb::clsfctn replay::aabb::classify(const plane3 &x) const 
}}}
  Classify the box in respect to a plane. 
====clear====
{{{
  replay::aabb & replay::aabb::clear()
}}}
  Clear the box to contain nothing. To be more precise the lower bounds will be MAX_FLOAT and the upper bounds will be -MAX_FLOAT. 
====compute_arvo_vector====
{{{
  replay::vector3f & replay::aabb::compute_arvo_vector(const vector3f &point, vector3f &result) const 
}}}
  the arvo vector is the difference of point and the closest point on the interval to it. 
====compute_arvo_vector====
{{{
  vector3f replay::aabb::compute_arvo_vector(const vector3f &point) const 
}}}
  Compute the shortest vector from the point to the box. 
====compute_center====
{{{
  replay::vector3f & replay::aabb::compute_center(vector3f &result) const 
}}}
  Compute the center of the box. 
====compute_center====
{{{
  vector3f replay::aabb::compute_center() const 
}}}
  Compute the center of the aabb. 
====compute_corner====
{{{
  vector3f replay::aabb::compute_corner(unsigned int index) const 
}}}
  Compute a corner of the aabb. 
====compute_corner====
{{{
  replay::vector3f & replay::aabb::compute_corner(unsigned int index, vector3f &result) const 
}}}
  Compute a given corner of the box, whereas the n'th bit in the index corresponds to the n'th axis in space. 
====compute_subinterval====
{{{
  replay::aabb & replay::aabb::compute_subinterval(unsigned int index, const vector3f &pivot, aabb &result) const 
}}}
  Compute a sub-aabb for octree-like splits. 
====contains====
{{{
  bool replay::aabb::contains(const vector3f &point) const 
}}}
  Check if a point is inside this box. 
====distance====
{{{
  float replay::aabb::distance(const vector3f &other) const 
}}}
  Compute the euclidean distance to the box using Arvo's algorithm. 
====expand====
{{{
  replay::aabb & replay::aabb::expand(const vector3f &x)
}}}
  Create the aabb [min-x,max+x]. 
====expanded====
{{{
  replay::aabb replay::aabb::expanded(const vector3f &x) const 
}}}
  Create the aabb [min-x,max+x]. 
====insert====
{{{
  replay::aabb & replay::aabb::insert(const vector3f *points, const unsigned short *indices, unsigned int count)
}}}
  Enlarge the aabb to contain the indexed points from the array. 
====insert====
{{{
  replay::aabb & replay::aabb::insert(const vector3f *points, const unsigned int *indices, unsigned int count)
}}}
  Enlarge the aabb to contain the indexed points from the array. 
====insert====
{{{
  replay::aabb & replay::aabb::insert(const aabb &x)
}}}
  Enlarge the aabb to contain another aabb. 
====insert====
{{{
  aabb& replay::aabb::insert(const vector3f &point)
}}}
  Enlarge the box to contain the given point. pointThe point to be inserted. 
====insert====
{{{
  replay::aabb & replay::aabb::insert(const vector3f *points, unsigned int count)
}}}
  Enlarge the aabb to contain the array of points. 
====max====
{{{
  const vector3f& replay::aabb::max() const 
}}}
  Get the maximum in all three dimensions. 
====max====
{{{
  vector3f& replay::aabb::max()
}}}
  Get the maximum in all three dimensions. 
====max====
{{{
  float& replay::aabb::max(IndexType i)
}}}
  Get the maximum element in the given dimension. 
====max====
{{{
  float replay::aabb::max(IndexType i) const 
}}}
  Get the maximum element in the given dimension. 
====min====
{{{
  const vector3f& replay::aabb::min() const 
}}}
  Get the minimum in all three dimensions. 
====min====
{{{
  vector3f& replay::aabb::min()
}}}
  Get the minimum in all three dimensions. 
====min====
{{{
  float replay::aabb::min(IndexType i) const 
}}}
  Get the minimum element in the given dimension. 
====min====
{{{
  float& replay::aabb::min(IndexType i)
}}}
  Get the minimum element in the given dimension. 
====move====
{{{
  replay::aabb & replay::aabb::move(const vector3f &delta)
}}}
  Move the box. 
====project====
{{{
  void replay::aabb::project(const vector3f &x, fcouple &result) const 
}}}
  Project the box onto a vector. 
====square_distance====
{{{
  float replay::aabb::square_distance(const vector3f &other) const 
}}}
  Compute the square distance to the box using Arvo's algorithm. 